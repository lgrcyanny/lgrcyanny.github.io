<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Dynamic Programming Summary | CyannyLive | AI and Big Data</title>

  
  <meta name="author" content="Cyanny Liang">
  

  
  <meta name="description" content="Wisdom comes from inside">
  

  
  
  <meta name="keywords" content="Algorithm,Dynamic Programming">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Dynamic Programming Summary"/>

  <meta property="og:site_name" content="CyannyLive"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="CyannyLive" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">CyannyLive</a>
    </h1>
    <p class="site-description">AI and Big Data</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="../../../../index.html">Home</a></li>
      
        <li><a href="../../../../archives">Archives</a></li>
      
        <li><a href="../../../../about/">About</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Dynamic Programming Summary</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/12/23/dynamic-programming-summary/" rel="bookmark">
        <time class="entry-date published" datetime="2021-12-23T03:11:31.000Z">
          2021-12-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="1-动态规划之道"><a href="#1-动态规划之道" class="headerlink" title="1. 动态规划之道"></a>1. 动态规划之道</h1><ul>
<li><strong>DP问题的特征</strong><ul>
<li>最优子结构: 原问题是一个最优化问题, 可递归地拆分为多个子问题, 通过数学方法组合各个子问题的最优解, 可以求得问题的最优解</li>
<li>重叠的子问题: 子问题相互重叠, 例如斐波拉契数列问题, 而子问题如果不重叠, 可以用一般的递归</li>
<li>无后效性: 某一个状态一旦确定, 就不受这个状态以后决策的影响, 例如地下城游戏<a id="more"></a></li>
</ul>
</li>
<li><strong>DP解题思路</strong><ul>
<li>状态定义, 即定义子问题, 弄清楚原问题和子问题的关系, 例如dp[n], 表示0..n上问题的解, 可以考虑缩减问题规模</li>
<li>状态转移, 即定义子问题之间的转换关系, 写出状态转移方程, 例如dp[i] = f(dp[i - 1]), i &lt; n</li>
<li>子问题相互重叠, 自底向上, 利用存储表, 一般是一维或二维数组, 如果数组稀疏, 可以用HashMap</li>
<li>注意初始化和边界条件</li>
</ul>
</li>
<li><strong>DP与其他算法的区别</strong><ul>
<li>DP与分治算法: 分治算法不要求子问题相互重叠</li>
<li>DP与贪心算法<ul>
<li>贪心要求最优子结构, 每一步的最优解包括上一步的最优解, 每次只求解一个最优子问题</li>
<li>贪心不保证全局最优, DP保证</li>
</ul>
</li>
</ul>
</li>
<li><strong>DP问题类型: 按结果类型分类</strong><ul>
<li>最值问题: 求最大值, 最小值</li>
<li>计数问题: 求组合总数, 路径总数等</li>
</ul>
</li>
<li><strong>DP问题类型: 按状态转移方程形式分类</strong><ul>
<li>线性问题: 问题规模i从小到大, 大规模问题的解依赖小规模问题的最优解, 例如LIS, 最大子数组和</li>
<li>前缀和问题: 求区间和 sum(i, j) = sums(0, j + 1) - sums(0, j)</li>
<li>区间问题: 例如: 最长回文字符串, 最长回文子序列</li>
<li>背包问题: 0-1背包问题, 完全背包问题</li>
<li>状态压缩: 例如旅行商问题, 求经过所有点的最短路径</li>
<li>计数问题: 例如卡特兰数</li>
<li>数位问题</li>
<li>矩阵快速幂: 对于线性递归式求解, 时间复杂度可以优化到O(logN)</li>
</ul>
</li>
</ul>
<h1 id="2-动态规划经典实战"><a href="#2-动态规划经典实战" class="headerlink" title="2. 动态规划经典实战"></a>2. 动态规划经典实战</h1><h2 id="2-1-线性动态规划"><a href="#2-1-线性动态规划" class="headerlink" title="2.1 线性动态规划"></a>2.1 线性动态规划</h2><p>线性动态规划是指状态的推导按问题规模的大小从小到大, 较大问题的求解可以划分为小规模问题.<br>状态定义一般是一维数组dp[i], 状态转移会依赖O(n)个子问题或O(1)个子问题. 按问题类型分, 主要有:</p>
<ul>
<li>单串问题: 包括最长上升子序列, 最大子数组和, 打家劫舍(不相邻子序列最大和), 需要两个位置的问题, 带维度的单串问题, 股票问题(带状态的单串问题)</li>
<li>双串问题: 包括最长公共子序列, 字符串匹配(例如最短编辑距离, 通配符匹配), 带维度的双串问题</li>
<li>矩阵问题: 最小路径和, 最大正方形, 最大矩形, 矩形区域不超过K的最大数值和</li>
<li>无串线性问题: 没有显示的字符串和数组, 但可以用线性动规, 例如丑数, 完全平方数</li>
</ul>
<h3 id="2-1-1-单串问题-最长上升子序列-LIS"><a href="#2-1-1-单串问题-最长上升子序列-LIS" class="headerlink" title="2.1.1 单串问题-最长上升子序列(LIS)"></a>2.1.1 单串问题-最长上升子序列(LIS)</h3><p>状态转移依赖O(n)个子问题</p>
<ul>
<li>状态定义<br>dp[i], 表示以nums[i]结尾的最长上升子序列的长度, 最终结果为max(dp[i]), 0 &lt;= i &lt; n</li>
<li>状态转移方程<br>p[i] = max(dp[j]) + 1,  0&lt;= j &lt; i, nums[j] &lt; nums[i]</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLISLengthDP</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = arr.size</span><br><span class="line">    <span class="keyword">val</span> memo = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](n) <span class="comment">// memo[i] is LIS from 0 to i</span></span><br><span class="line">    memo(<span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> until n) &#123;</span><br><span class="line">      memo(i) = <span class="number">1</span></span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">0</span> until i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr(j) &lt; arr(i) &amp;&amp; memo(j) + <span class="number">1</span> &gt; memo(i)) &#123;</span><br><span class="line">          memo(i) = memo(j) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (memo(i) &gt; maxLen) &#123;</span><br><span class="line">        maxLen = memo(i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-单串问题-求具有最大和的连续子数组"><a href="#2-1-2-单串问题-求具有最大和的连续子数组" class="headerlink" title="2.1.2 单串问题-求具有最大和的连续子数组"></a>2.1.2 单串问题-求具有最大和的连续子数组</h3><p>给一个整数数组nums, 找一个具有最大和的连续子数组, 输出最大和</p>
<ul>
<li>状态定义 <ul>
<li>dp[i] 表示以nums[i]结尾的最大连续子数组和</li>
<li>整个数组的最大连续子序和即所有dp[i]的最大值, res = max(dp[i]), 0 &lt;= i &lt; n</li>
</ul>
</li>
<li>状态转移: (Kanade算法)<ul>
<li>dp[i] = max(dp[i - 1], 0) + nums[i] </li>
<li>或者 dp[i] = max(nums[i], nums[i] + dp[i - 1])</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMaxSubArr</span></span>(nums: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> maxSum = nums(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> maxEnding = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until nums.size) &#123;</span><br><span class="line">      maxEnding = <span class="type">Math</span>.max(maxEnding, <span class="number">0</span>) + nums(i)</span><br><span class="line">      <span class="keyword">if</span> (maxEnding &gt; maxSum) &#123;</span><br><span class="line">        maxSum = maxEnding</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题变种: 例如求循环子数组的最大和</strong><br>解法巧秒的是, 求子数组的最大和, 最小和, 最终结果为max(max_sub, all_sum - min_sub).</p>
<ul>
<li>状态定义: <ul>
<li>max_dp[i] 表示以nums[i]结尾的最大连续子数组和</li>
<li>min_dp[i] 表示以nums[i]结尾的最小连续子数组和</li>
</ul>
</li>
<li>状态转移<ul>
<li>max_dp[i] = max(max_dp[i - 1] + nums(i), nums(i))</li>
<li>in_dp[i] = min(min_dp[i - 1] + nums(i), nums(i))</li>
</ul>
</li>
<li>最终结果<ul>
<li>max_dp = max(max_dp[i]),  0 &lt;= i &lt; n</li>
<li>min_dp = min(min_dp[i]),  0 &lt;= i &lt; n</li>
<li>max(max_dp, all_sum - min_dp)<br>这里为了优化空间复杂度为O(1), 只需记录max_dp[i]的最大值和min_dp[i]的最小值</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArraySumCircular</span></span>(nums: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nums.size</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">      nums(<span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> maxSum = nums.max</span><br><span class="line">      <span class="keyword">var</span> minSum = nums.min</span><br><span class="line">      <span class="keyword">var</span> maxEnding = <span class="number">0</span></span><br><span class="line">      <span class="keyword">var</span> minEnding = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">        maxEnding = <span class="type">Math</span>.max(maxEnding + nums(i), nums(i))</span><br><span class="line">        minEnding = <span class="type">Math</span>.min(minEnding + nums(i), nums(i))</span><br><span class="line">        maxSum = <span class="type">Math</span>.max(maxSum, maxEnding)</span><br><span class="line">        minSum = <span class="type">Math</span>.min(minSum, minEnding)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> allSum = nums.sum</span><br><span class="line">      <span class="keyword">if</span> (maxSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxSum</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Math</span>.max(maxSum, allSum - minSum)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-单串问题-打家劫舍-不相邻子序列最大和"><a href="#2-1-3-单串问题-打家劫舍-不相邻子序列最大和" class="headerlink" title="2.1.3 单串问题-打家劫舍(不相邻子序列最大和)"></a>2.1.3 单串问题-打家劫舍(不相邻子序列最大和)</h3><p>问题是一个小偷沿途偷盗房屋, 每个房屋内有现金, 相邻房屋有警报, 不能触发报警, 求能偷到的现金的最大值. 该问题是求不连续子序列的最大值</p>
<ul>
<li>状态定义: dp[i]表示以i结尾的最大非连续子序列的和</li>
<li>状态转移: dp[i] = max(dp[i - 1], dp[i - 2] + nums(i))</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span></span>(nums: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nums.size</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">      nums(<span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> maxEnding0 = nums(<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">var</span> maxEnding1 = <span class="type">Math</span>.max(nums(<span class="number">1</span>), maxEnding0)</span><br><span class="line">      <span class="keyword">var</span> maxSum = maxEnding1</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">2</span> until n) &#123;</span><br><span class="line">        <span class="keyword">val</span> t = <span class="type">Math</span>.max(maxEnding1, maxEnding0 + nums(i))</span><br><span class="line">        maxEnding0 = maxEnding1</span><br><span class="line">        maxEnding1 = t</span><br><span class="line">        maxSum = <span class="type">Math</span>.max(maxSum, t)</span><br><span class="line">      &#125;</span><br><span class="line">      maxSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-单串问题-需要两个位置"><a href="#2-1-4-单串问题-需要两个位置" class="headerlink" title="2.1.4 单串问题-需要两个位置"></a>2.1.4 单串问题-需要两个位置</h3><p>求一个数组中最长斐波那契子序列的长度, 这里问题定义需要考虑两个位置</p>
<ul>
<li>状态定义 <ul>
<li>dp[i][j]表示以i, j结尾的最长斐波拉契子序列的长度</li>
</ul>
</li>
<li>状态转移<ul>
<li>dp[j][k] = dp[i][j] + 1, if A[i] + A[j] == A[k]</li>
</ul>
</li>
<li>实现细节<ul>
<li>需要用一个HashSet维护一个Arr[k] -&gt; k的索引表</li>
<li>由于dp是稀疏二维矩阵, 用hashmap替代</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestFibSubSeq</span></span>(nums: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nums.size</span><br><span class="line">    <span class="keyword">val</span> index = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">      index.put(nums(i), i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">    <span class="comment">// dp as HashMap because 2-dimension array is sparse</span></span><br><span class="line">    <span class="keyword">val</span> dp = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">for</span> (k &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">0</span> until k) &#123;</span><br><span class="line">        <span class="comment">// test if A[k] = A[i] + A[j]</span></span><br><span class="line">        <span class="keyword">val</span> i = index.getOrElse(nums(k) - nums(j), <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">          dp(j * n + k) = dp.getOrElse(i * n + j, <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">          res = <span class="type">Math</span>.max(res, dp(j * n + k))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">      res</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-单串问题-带维度的问题"><a href="#2-1-5-单串问题-带维度的问题" class="headerlink" title="2.1.5 单串问题-带维度的问题"></a>2.1.5 单串问题-带维度的问题</h3><p>经典的鸡蛋掉落问题, n层楼, k个鸡蛋, 求鸡蛋不碎的最少掉落次数</p>
<ul>
<li>状态定义: dp[i][k]表示层数为i,k个鸡蛋的最小操作次数</li>
<li>状态转移: 假设在第f层抛鸡蛋, 两种情况<ul>
<li>鸡蛋碎了, 剩余k-1个鸡蛋, 在f层以下下搜索, 问题转换为dp[f - 1][k - 1]</li>
<li>鸡蛋没有碎, 还是k个鸡蛋, 在f层以上搜索, 问题转换为dp[i - f][k]</li>
<li>因此, dp[i][k] = 1 + min(max(dp[f - 1][k - 1], dp[i - f][k])), 1&lt;= f &lt;= i</li>
<li>在搜索时需要用二分查找, 优化时间复杂度</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span></span>(<span class="type">K</span>: <span class="type">Int</span>, n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](n + <span class="number">1</span>, <span class="type">K</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (k &lt;- <span class="number">0</span> to <span class="type">K</span>) &#123;</span><br><span class="line">      dp(<span class="number">0</span>)(k) = <span class="number">0</span></span><br><span class="line">      dp(<span class="number">1</span>)(k) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">      dp(i)(<span class="number">1</span>) = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">2</span> to n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (k &lt;- <span class="number">2</span> to <span class="type">K</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> right = i</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">          <span class="keyword">val</span> x = (left + right) / <span class="number">2</span></span><br><span class="line">          <span class="keyword">val</span> t1 = dp(x - <span class="number">1</span>)(k - <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">val</span> t2 = dp(i - x)(k)</span><br><span class="line">          <span class="keyword">if</span> (t1 &lt; t2) &#123;</span><br><span class="line">            left = x</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">            right = x</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = x</span><br><span class="line">            right = x</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp(i)(k) = <span class="number">1</span> + <span class="type">Math</span>.min(</span><br><span class="line">          <span class="type">Math</span>.max(dp(left - <span class="number">1</span>)(k - <span class="number">1</span>), dp(i - left)(k)),</span><br><span class="line">          <span class="type">Math</span>.max(dp(right - <span class="number">1</span>)(k - <span class="number">1</span>), dp(i - right)(k))</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(n)(<span class="type">K</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-6-单串问题-股票买卖-考虑状态"><a href="#2-1-6-单串问题-股票买卖-考虑状态" class="headerlink" title="2.1.6 单串问题-股票买卖, 考虑状态"></a>2.1.6 单串问题-股票买卖, 考虑状态</h3><p>给定一个数组, price[i]表示第i天的股票价格, 假设可以完成多笔交易, 最终获得股票的最大利润</p>
<ul>
<li>状态定义: dp[i][0] 表示第i天结束, 手里没有股票的最大收益, dp[i][1]表示第i天结束, 手里有股票的最大收益</li>
<li>状态转移<ul>
<li>dp[i][0] = max{dp[i - 1][0], dp[i - 1][1] + prices[i]}</li>
<li>dp[i][1] = max{dp[i - 1][1], dp[i - 1][0] - prices[i]}</li>
</ul>
</li>
<li>边界条件<ul>
<li>dp[0][0] = 0, dp[0][1] = -prices[0]</li>
</ul>
</li>
<li>计算优化<ul>
<li>由于只依赖前一个值dp[i-1], 因此只需要保存两个变量dp0, dp1</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span></span>(prices: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = prices.size</span><br><span class="line">    <span class="keyword">var</span> dp0 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> dp1 = -prices(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> until n) &#123;</span><br><span class="line">      dp0 = <span class="type">Math</span>.max(dp0, dp1 + prices(i))</span><br><span class="line">      dp1 = <span class="type">Math</span>.max(dp1, dp0 - prices(i))</span><br><span class="line">    &#125;</span><br><span class="line">    dp0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-7-双串问题-最长公共子序列-LCS"><a href="#2-1-7-双串问题-最长公共子序列-LCS" class="headerlink" title="2.1.7 双串问题-最长公共子序列(LCS)"></a>2.1.7 双串问题-最长公共子序列(LCS)</h3><ul>
<li>状态定义: dp[i][j]表示字符串text1 = 0..i和字符串text2=0..j的最大公共子序列长度</li>
<li>状态转移<ul>
<li>dp[i][j] = max(dp[i-1][j], dp[i][j-1]), if text1[i] != text2[j]</li>
<li>dp[i][j] = dp[i-1][j-1] + 1, if text1[i] == text2[j]</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span></span>(text1: <span class="type">String</span>, text2: <span class="type">String</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> m = text1.size</span><br><span class="line">    <span class="keyword">val</span> n = text2.size</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](m + <span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to m) &#123;</span><br><span class="line">      dp(i)(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j &lt;- <span class="number">0</span> to n) &#123;</span><br><span class="line">      dp(<span class="number">0</span>)(j) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to m) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (text1(i - <span class="number">1</span>) == text2(j - <span class="number">1</span>)) &#123;</span><br><span class="line">          dp(i)(j) = dp(i - <span class="number">1</span>)(j - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp(i)(j) = <span class="type">Math</span>.max(dp(i - <span class="number">1</span>)(j), dp(i)(j - <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(printLCS(text1, text2, dp))</span><br><span class="line">    dp(m)(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-8-双串问题-字符串匹配"><a href="#2-1-8-双串问题-字符串匹配" class="headerlink" title="2.1.8 双串问题-字符串匹配"></a>2.1.8 双串问题-字符串匹配</h3><p>编辑距离: 求把字符串word1通过插入, 删除, 替换为word2的最短操作次数</p>
<ul>
<li>状态定义: dp[i][j]表示从word1[0..i]变为word2[0..j]的最少操作步骤</li>
<li>状态转移:<ul>
<li>if word1[i] == word2[j]<ul>
<li>dp[i][j] = dp[i - 1][j - 1]</li>
</ul>
</li>
<li>if word1[i] != word2[j]<ul>
<li>deleteCost = dp[i-1][j] + 1</li>
<li>insertCost = dp[i][j - 1] + 1</li>
<li>updateCost = dp[i -1][j - 1] + 1</li>
<li>dp[i][j] = min(deleteCost, insertCost, updateCost)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span></span>(word1: <span class="type">String</span>, word2: <span class="type">String</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> m = word1.size</span><br><span class="line">    <span class="keyword">val</span> n = word2.size</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](m + <span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to m) &#123;</span><br><span class="line">      dp(i)(<span class="number">0</span>) = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j &lt;- <span class="number">0</span> to n) &#123;</span><br><span class="line">      dp(<span class="number">0</span>)(j) = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to m) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word1(i - <span class="number">1</span>) == word2(j - <span class="number">1</span>)) &#123;</span><br><span class="line">          dp(i)(j) = dp(i - <span class="number">1</span>)(j - <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp(i)(j) = <span class="type">Array</span>(dp(i - <span class="number">1</span>)(j), dp(i)(j - <span class="number">1</span>), dp(i - <span class="number">1</span>)(j - <span class="number">1</span>)).min + <span class="number">1</span> <span class="comment">// delete, insert, update cost</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(m)(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题变种: 通配符匹配问题</strong></p>
<ul>
<li>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配, 输入s和p, 输出s是否和p匹配</li>
<li>状态定义: dp[i][j]表示字符串s[0..i], p[0..j]是否匹配</li>
<li>状态转移:<ul>
<li>dp[i][j] = (dp[i - 1][j - 1])  if (s[i] == p[j]) or p[j] == ‘?’</li>
<li>dp[i][j] = or(dp[i-1][j], dp[i][j - 1]) , if p[j] == ‘*’, 匹配时使用或不使用星号</li>
<li>dp[i][j] = false, 其他情况</li>
</ul>
</li>
<li>边界条件<ul>
<li>dp[0][0] = true</li>
<li>dp[i][0] = false</li>
<li>dp[0][j] = true, if p[0..j]都是星号</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span></span>(word1: <span class="type">String</span>, word2: <span class="type">String</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> m = word1.size</span><br><span class="line">    <span class="keyword">val</span> n = word2.size</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](m + <span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to m) &#123;</span><br><span class="line">      dp(i)(<span class="number">0</span>) = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j &lt;- <span class="number">0</span> to n) &#123;</span><br><span class="line">      dp(<span class="number">0</span>)(j) = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to m) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word1(i - <span class="number">1</span>) == word2(j - <span class="number">1</span>)) &#123;</span><br><span class="line">          dp(i)(j) = dp(i - <span class="number">1</span>)(j - <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp(i)(j) = <span class="type">Array</span>(dp(i - <span class="number">1</span>)(j), dp(i)(j - <span class="number">1</span>), dp(i - <span class="number">1</span>)(j - <span class="number">1</span>)).min + <span class="number">1</span> <span class="comment">// delete, insert, update cost</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(m)(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-9-矩阵问题-最大正方形"><a href="#2-1-9-矩阵问题-最大正方形" class="headerlink" title="2.1.9 矩阵问题-最大正方形"></a>2.1.9 矩阵问题-最大正方形</h3><p>在由’0’和’1’组成的二维矩阵内, 找到只包含’1’的最大正方形, 并返回面积<br>例如如下矩阵, 最大正方形面积为4</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matrix = <span class="type">Array</span>(</span><br><span class="line">      <span class="type">Array</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>),</span><br><span class="line">      <span class="type">Array</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>),</span><br><span class="line">      <span class="type">Array</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>),</span><br><span class="line">      <span class="type">Array</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<ul>
<li>状态定义: dp[i][j]表示以(i,j)为右下角的只包含1的最大正方形的边长</li>
<li>状态转移<ul>
<li>dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1, if matrix[i][j] == 1</li>
<li>dp[i][j] = 0, if matrix[i][j] == 0</li>
</ul>
</li>
<li>边界条件<ul>
<li>dp[0][j] = 1, if matrix[0][j] == 1 </li>
<li>dp[i][0] = 1, if matrix[i][0] == 1</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span></span>(matrix: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">Char</span>]]): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> m = matrix.size</span><br><span class="line">    <span class="keyword">val</span> n = matrix(<span class="number">0</span>).size</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](m, n)</span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until m) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix(i)(j) == &#x27;<span class="number">1</span>&#x27;) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">            dp(i)(j) = <span class="number">1</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp(i)(j) = <span class="type">Array</span>(dp(i - <span class="number">1</span>)(j), dp(i)(j - <span class="number">1</span>), dp(i - <span class="number">1</span>)(j - <span class="number">1</span>)).min + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp(i)(j) = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="type">Math</span>.max(res, dp(i)(j))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res * res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-10-矩阵问题-最大子矩阵"><a href="#2-1-10-矩阵问题-最大子矩阵" class="headerlink" title="2.1.10 矩阵问题-最大子矩阵"></a>2.1.10 矩阵问题-最大子矩阵</h3><p>给定一个正整数、负整数和 0 组成的 N × M矩阵，编写代码找出元素总和最大的子矩阵。<br>返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可</p>
<p>本题目的技巧是将二维矩阵问题转化为一维的动态规划问题<br>设数组colSum[k]表示从第i行到第j行的列和, 问题转化为求一维数组colSum的最大子数组和</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMaxMatrix</span></span>(matrix: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">Int</span>]]): <span class="type">Array</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> res = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="type">N</span> = matrix.length</span><br><span class="line">    <span class="keyword">val</span> <span class="type">M</span> = matrix(<span class="number">0</span>).length</span><br><span class="line">    <span class="keyword">var</span> maxSum = matrix(<span class="number">0</span>)(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> maxEnding = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> tempX = <span class="number">0</span> <span class="comment">// temp coordinate</span></span><br><span class="line">    <span class="keyword">var</span> tempY = <span class="number">0</span> <span class="comment">// temp coordinate</span></span><br><span class="line">    <span class="keyword">val</span> colSum = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="type">M</span>) <span class="comment">// column sum from i to j</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="type">N</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (t &lt;- <span class="number">0</span> until <span class="type">M</span>) &#123;</span><br><span class="line">        colSum(t) = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- i until <span class="type">N</span>) &#123;</span><br><span class="line">        maxEnding = <span class="number">0</span> <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="keyword">for</span> (k &lt;- <span class="number">0</span> until <span class="type">M</span>) &#123;</span><br><span class="line">          colSum(k) = colSum(k) + matrix(j)(k)</span><br><span class="line">          <span class="keyword">if</span> (maxEnding &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxEnding = colSum(k) + maxEnding</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxEnding = colSum(k)</span><br><span class="line">            tempX = i</span><br><span class="line">            tempY = k</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (maxEnding &gt; maxSum) &#123;</span><br><span class="line">            maxSum = maxEnding</span><br><span class="line">            res(<span class="number">0</span>) = tempX</span><br><span class="line">            res(<span class="number">1</span>) = tempY</span><br><span class="line">            res(<span class="number">2</span>) = j</span><br><span class="line">            res(<span class="number">3</span>) = k</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-前缀和问题"><a href="#2-2-前缀和问题" class="headerlink" title="2.2 前缀和问题"></a>2.2 前缀和问题</h2><p>前缀和是线性动态规划的一种, 前缀和隐含了动态规划的思想<br><strong>1.什么是前缀和</strong></p>
<ul>
<li>状态定义：sums[i] := [0..i-1] 的和</li>
<li>状态转移：sums[i] = a[i - 1] + sums[i - 1]</li>
<li>初始化：sums[0] = 0</li>
</ul>
<p><strong>2.常见问题</strong></p>
<ul>
<li>求区间和: sum(i, j) = sums(0, j + 1) - sums(0, j)</li>
<li>快速求矩形和: sum(abcd)=sum(od)−sum(ob)−sum(oc)+sum(oa)</li>
<li>结合数据结构哈希表, 记录查询前缀和结果<ul>
<li>和为k的最长子数组, key为前缀和, value为索引</li>
<li>和为k的子数组个数, key为前缀和, value为count数</li>
</ul>
</li>
<li>逆运算差分: 差分数组的前缀和是原数组</li>
</ul>
<h3 id="2-2-1-求数组的区间和"><a href="#2-2-1-求数组的区间和" class="headerlink" title="2.2.1 求数组的区间和"></a>2.2.1 求数组的区间和</h3><p>给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>(<span class="params">_nums: <span class="type">Array</span>[<span class="type">Int</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> n = _nums.size</span><br><span class="line">    <span class="keyword">val</span> prefix = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](n + <span class="number">1</span>)</span><br><span class="line">    buildPrefixSum()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">buildPrefixSum</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      prefix(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">        prefix(i) = prefix(i - <span class="number">1</span>) + _nums(i - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span></span>(left: <span class="type">Int</span>, right: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">      prefix(right + <span class="number">1</span>) - prefix(left)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-用HashMap维护前缀和"><a href="#2-2-2-用HashMap维护前缀和" class="headerlink" title="2.2.2 用HashMap维护前缀和"></a>2.2.2 用HashMap维护前缀和</h3><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数<br>hashmap&lt;前缀和的值, 出现次数&gt;, 检测当pre[j−1] == pre[i]−k, count值累加</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span></span>(nums: <span class="type">Array</span>[<span class="type">Int</span>], k: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nums.size</span><br><span class="line">    <span class="keyword">val</span> map = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> prefixSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">      prefixSum = prefixSum + nums(i)</span><br><span class="line">      <span class="keyword">val</span> t = prefixSum - k</span><br><span class="line">      <span class="keyword">if</span> (map.contains(t)) &#123;</span><br><span class="line">        maxCount = maxCount + map(t)</span><br><span class="line">      &#125;</span><br><span class="line">      map.put(prefixSum, map.getOrElse(prefixSum, <span class="number">0</span>) + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    maxCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-3-区间问题"><a href="#2-3-区间问题" class="headerlink" title="2.3 区间问题"></a>2.3 区间问题</h2><ul>
<li>状态定义dp[i][j], 表示原问题在区间[i..j]上的解</li>
<li>状态转移<ul>
<li>与常数个规模较小的子问题相关, 时间复杂度为O(n^2)<ul>
<li>例如: 最长回文子串, dp[i][j] = f(dp[i + 1][j], dp[i + 1][j - 1], dp[i][j - 1])</li>
</ul>
</li>
<li>与O(n)个更小规模的子问题有关, O(n^3)<ul>
<li>dp[i][j] = g(f(dp[i][k], dp[k + 1][j])) 其中 k = i .. j-1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-1-最长回文子串"><a href="#2-3-1-最长回文子串" class="headerlink" title="2.3.1 最长回文子串"></a>2.3.1 最长回文子串</h3><p>求字符串s的最长回文子串, </p>
<ul>
<li>例如s=”abbacd”, 答案是”abba”</li>
<li>s=”a”, 答案是”a”</li>
</ul>
<p>解题思路:<br>注意最长回文子串, 不是最长回文子序列, 前者是连续的, 后者不要求连续, 因此dp数组要用boolean类型:</p>
<ul>
<li>状态定义: dp[i][j]表示从i到j的子串是否是回文</li>
<li>状态转移:<ul>
<li>dp[i][j] = dp[i+1][j - 1],  if s[i] == s[j], 长度大于2</li>
<li>dp[i][j] = false, if s[i] != s[j]</li>
</ul>
</li>
<li>边界条件:<br>dp[i][i] = true<br>dp[i][j] = true, if j - i &lt; 3, 类似”aa”, “aca”这样的长度为2或3的字符串</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span></span>(s: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = s.size</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Boolean</span>](n, n)</span><br><span class="line">    <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> begin = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (len &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">val</span> j = i + len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            dp(i)(j) = <span class="literal">true</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s(i) != s(j)) &#123;</span><br><span class="line">            dp(i)(j) = <span class="literal">false</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">              dp(i)(j) = <span class="literal">true</span> <span class="comment">// such as &quot;aca&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              dp(i)(j) = dp(i + <span class="number">1</span>)(j - <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (dp(i)(j) &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">            maxLen = j - i + <span class="number">1</span></span><br><span class="line">            begin = i</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.substring(begin, begin + maxLen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-最长回文子序列"><a href="#2-3-2-最长回文子序列" class="headerlink" title="2.3.2 最长回文子序列"></a>2.3.2 最长回文子序列</h3><p>给你一个字符串s ，找出其中最长的回文子序列，并返回该序列的长度, 例如s=”bbbab”, 输出是”bbbb”</p>
<ul>
<li>状态定义: dp[i][j]表示从i到j的最长回文子串长度, 最终结果为dp[0][n - 1]</li>
<li>状态转移<ul>
<li>dp[i][j] = dp[i+1][j - 1] + 2, if s[i] == s[j]</li>
<li>dp[i][j] = max{dp[i + 1][j], dp[i][j - 1]}, if s[i] != s[j]<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span></span>(s: <span class="type">String</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = s.size</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](n, n) <span class="comment">// it&#x27;s sparse, can replace with hashmap</span></span><br><span class="line">    <span class="keyword">for</span> (len &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">val</span> j = i + len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            dp(i)(j) = <span class="number">1</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s(i) != s(j)) &#123;</span><br><span class="line">            dp(i)(j) = <span class="type">Math</span>.max(dp(i + <span class="number">1</span>)(j), dp(i)(j - <span class="number">1</span>))</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp(i)(j) = dp(i + <span class="number">1</span>)(j - <span class="number">1</span>) + <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(<span class="number">0</span>)(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="2-4-背包问题"><a href="#2-4-背包问题" class="headerlink" title="2.4 背包问题"></a>2.4 背包问题</h2><p><strong>1.0-1背包问题</strong></p>
<ul>
<li>问题定义: 有n种物品，物品j的体积为v(j), 价值为w(j), 有一个体积限制V。每种物品只有 1 个，只有选或者不选</li>
<li>状态定义: dp[i][j] := 考虑了[0..i]里的物品，占用了j空间，所能取得的最大价值</li>
<li>状态转移:<ul>
<li>dp[i][j] = max(dp[i - 1][j] 当前物品不选, dp[i - 1][j - v[i]] + w[i] 当前物品选), if j - v[i] &gt;= 0</li>
</ul>
</li>
<li>空间优化<ul>
<li>用一维数组, 防止遍历时产生覆盖, j需要从大到小遍历</li>
<li>dp[j] = max{dp[j], dp[j - v[i]] + w[i]}</li>
</ul>
</li>
<li>如果背包要求装满<ul>
<li>初始化dp[i][j]为-1, 表示方案不可取, dp[0][0] = 0</li>
<li>状态转移时，需要判断dp[i - 1][j - v[i]] != -1</li>
</ul>
</li>
</ul>
<p><strong>2.完全背包问题</strong></p>
<ul>
<li>问题定义: 有n种物品，物品j的体积为v[j]，价值为w[i]，有一个体积限制V, 每种物品有无限个</li>
<li>状态定义: dp[i][j] := 考虑了[0..i]里的物品，占用了j空间，所能取得的最大价值</li>
<li>状态转移:<ul>
<li>dp[i][j] = max(dp[i - 1][j] 当前物品不选, <strong>dp[i][j - v[i]]</strong> + w[i] 当前物品选)，if j - v[i] &gt;= 0</li>
</ul>
</li>
<li>空间优化<ul>
<li>用一维数组, j从小到大遍历</li>
<li>dp[j] = max{dp[j], dp[j - v[i] + w[i]]}</li>
</ul>
</li>
</ul>
<p><strong>3.多重背包问题</strong></p>
<ul>
<li>问题定义<br>有 n 种物品，物品 j 的体积为 v[j]，价值为 w[i]，有一个体积限制 V 。每种物品还有一个c[i] ，表示每种物品的个数</li>
<li>问题思路<br>对于物品 i, 数量限制是c[i] , 可以将其分成若干物品，它们的价值和体积为：(w[i], v[i]), (2 * w[i], 2 * v[i]) .., 超过体积限制的就不要, 然后对这些物品做0-1背包问题 </li>
</ul>
<p><strong>4.问题类型</strong><br>    - 最值问题: 例如零钱兑换<br>    - 恰好取到背包容量: 例如分割等和子集<br>    - 组合问题（求方案数）: 需要考虑组合的顺序问题, 例如零钱兑换就是无顺序的</p>
<h3 id="2-4-1-最值问题"><a href="#2-4-1-最值问题" class="headerlink" title="2.4.1 最值问题"></a>2.4.1 最值问题</h3><p>零钱兑换问题<br>给你一个整数数组coins，表示不同面额的硬币, 硬币数量无限多；以及一个整数amount，表示总金额<br>计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1</p>
<p>这是一个完全背包问题</p>
<ul>
<li>状态定义: dp[j]表示0..i种硬币, 找零总金额为j的最小硬币数量</li>
<li>状态转移: dp[j] = min{[j], dp[j - coins[i]] + 1} ,  j &gt;= coins[i]</li>
<li>初始化<ul>
<li>dp[j] = Int.Max - 1</li>
<li>dp[0] = 0</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChangeOpt</span></span>(coins: <span class="type">Array</span>[<span class="type">Int</span>], amount: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = coins.size</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](amount + <span class="number">1</span>)</span><br><span class="line">    dp(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to amount) &#123;</span><br><span class="line">      dp(j) = <span class="type">Int</span>.<span class="type">MaxValue</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j &lt;- <span class="number">0</span> to amount) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (coins(i) &lt;= j) &#123;</span><br><span class="line">          dp(j) = <span class="type">Math</span>.min(dp(j), dp(j - coins(i)) + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> res = dp(amount)</span><br><span class="line">    <span class="keyword">if</span> (res &gt; amount) <span class="number">-1</span> <span class="keyword">else</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-恰好取到背包容量"><a href="#2-4-2-恰好取到背包容量" class="headerlink" title="2.4.2 恰好取到背包容量"></a>2.4.2 恰好取到背包容量</h3><p>给你一个只包含正整数的非空数组nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等<br>先求数组总和total, 如果total是奇数, 则不可分, 如果是偶数可以继续下面的步骤<br>令halfSum = total / 2, 问题转化为0-1背包问题, 从数组中取一个子集, 其总和为halfSum, 并要求背包填满</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span></span>(nums: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nums.size</span><br><span class="line">    <span class="keyword">val</span> totalSum = nums.sum</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || totalSum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> halfSum = totalSum / <span class="number">2</span></span><br><span class="line">      <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](halfSum + <span class="number">1</span>)</span><br><span class="line">      dp(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to halfSum) &#123;</span><br><span class="line">        dp(j) = <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j &lt;- halfSum to <span class="number">0</span> by <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (j &gt;= nums(i) &amp;&amp; dp(j - nums(i)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            dp(j) = <span class="type">Math</span>.max(dp(j), dp(j - nums(i)) + nums(i))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      dp(halfSum) != <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-求组合的方案数"><a href="#2-4-3-求组合的方案数" class="headerlink" title="2.4.3 求组合的方案数"></a>2.4.3 求组合的方案数</h3><p>求零钱兑换问题的方案总数<br>完全背包问题, 组合没有顺序</p>
<ul>
<li>状态定义: dp[j]表达前i个硬币, target为j时的组合数</li>
<li>状态转移<ul>
<li>dp[j] = dp[j] + dp[j - coins[i]], if j &gt;= nums[i]</li>
<li>j的遍历方向是从小到大, 因为coins[i]可以被选择多次</li>
<li>由于组合没有顺序性, i的遍历在外层, j的遍历在内层</li>
</ul>
</li>
<li>边界条件<ul>
<li>dp[0] = 1, 表达target为0, 方案数为空集</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span></span>(amount: <span class="type">Int</span>, coins: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = coins.size</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](amount + <span class="number">1</span>)</span><br><span class="line">    dp(<span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to amount) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= coins(i)) &#123;</span><br><span class="line">          dp(j) = dp(j) + dp(j - coins(i))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(amount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-状态压缩"><a href="#2-5-状态压缩" class="headerlink" title="2.5 状态压缩"></a>2.5 状态压缩</h2><p>状态压缩动态规划，用于NP问题的小规模求解, 是利用计算机二进制的性质来描述状态</p>
<h3 id="2-5-1-旅行商问题"><a href="#2-5-1-旅行商问题" class="headerlink" title="2.5.1 旅行商问题"></a>2.5.1 旅行商问题</h3><p>一个商人想要旅行各地并进行贸易。各地之间有若干条单向的通道相连，商人从一个地方出发，想要用最短的路程把所有地区环游一遍，请问环游需要的最短路程是多少？这里graph用邻接链表表示, 例如graph=[[1, 2, 3], [0], [0], [0]], 最短路径长度为4</p>
<ul>
<li>预处理: 用floyd算法计算任意两个点对之间的最短路径distance[i][j]</li>
<li>状态定义:<ul>
<li>dp[s][i]表达最后一个节点是i, 状态是s的最短路径</li>
<li>状态s是一个mask, s的二进制s[v]表示已经搜索过节点v</li>
</ul>
</li>
<li>状态转移<ul>
<li>dp[s][i] =  min {dp[s\i][v] + distance[v][i]}, 遍历上一个节点v, v的状态是没有搜索过节点i, 求最短路径</li>
<li>最终结果: min{dp[2^n - 1][i]}</li>
<li>边界条件<ul>
<li>当s中只有一个1, 表示开始节点, dp[s][i] = 0</li>
<li>默认dp[s][i] = Int.Max</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shortestPathLength</span></span>(graph: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">Int</span>]]): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = graph.size</span><br><span class="line">    <span class="keyword">val</span> states = <span class="number">1</span> &lt;&lt; n</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](states, n)</span><br><span class="line">    <span class="keyword">val</span> distance = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](n, n + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// floyd algorithm for min distance between each pair</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">        distance(i)(j) = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (graph(i).contains(j)) &#123;</span><br><span class="line">          distance(i)(j) = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">          distance(i)(j) = <span class="type">Math</span>.min(distance(i)(j), distance(i)(k) + distance(k)(j))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp algorithm</span></span><br><span class="line">    <span class="keyword">for</span> (s &lt;- <span class="number">0</span> until states) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">        dp(s)(i) = <span class="type">Int</span>.<span class="type">MaxValue</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (s &lt;- <span class="number">1</span> until states) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="comment">// s is 2 ^ k</span></span><br><span class="line">        <span class="keyword">if</span> ((s &amp; (s - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">          dp(s)(i) = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> ((s &amp; <span class="number">1</span> &lt;&lt; i) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (v &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">              <span class="keyword">if</span> ((s &amp; (<span class="number">1</span> &lt;&lt; v)) != <span class="number">0</span> &amp;&amp; (v != i)) &#123;</span><br><span class="line">                dp(s)(i) = <span class="type">Math</span>.min(dp(s)(i), dp(s ^ (<span class="number">1</span> &lt;&lt; i))(v) + distance(v)(i))</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(states - <span class="number">1</span>).min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路二: 用广度优先遍历+状态压缩</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPathLengthBFS</span></span>(graph: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">Int</span>]]): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> visited = <span class="keyword">new</span> mutable.<span class="type">HashSet</span>[(<span class="type">Int</span>, <span class="type">Int</span>)]()</span><br><span class="line">    <span class="keyword">val</span> queue = <span class="keyword">new</span> mutable.<span class="type">Queue</span>[(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)]() <span class="comment">// identity, mask, distance</span></span><br><span class="line">    <span class="keyword">val</span> n = graph.size</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">      visited.add((i, <span class="number">1</span> &lt;&lt;i))</span><br><span class="line">      queue.enqueue((i, <span class="number">1</span> &lt;&lt; i, <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> isDone = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.nonEmpty &amp;&amp; !isDone) &#123;</span><br><span class="line">      <span class="keyword">val</span> (i, mask, dist) = queue.dequeue()</span><br><span class="line">      <span class="keyword">if</span> (mask == ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)) &#123;</span><br><span class="line">        isDone = <span class="literal">true</span></span><br><span class="line">        res = dist</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- graph(i)) &#123;</span><br><span class="line">        <span class="keyword">val</span> maskForJ = mask | <span class="number">1</span> &lt;&lt; j</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains((j, maskForJ))) &#123;</span><br><span class="line">          queue.enqueue((j, maskForJ, dist + <span class="number">1</span>))</span><br><span class="line">          visited.add((j, maskForJ))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-计数问题"><a href="#2-6-计数问题" class="headerlink" title="2.6 计数问题"></a>2.6 计数问题</h2><p>有两种模式:<br>1.找到组合数公式，然后用DP的方式或者用含阶乘的公式求组合数, 例如: 路径问题<br>2.找到递归关系，然后以DP的方式求这个递推关系，如果是线性递推关系，可以用矩阵快速幂加速 例如:隐晦的递推关系: 栅栏涂色</p>
<h3 id="2-6-1-组合数问题"><a href="#2-6-1-组合数问题" class="headerlink" title="2.6.1 组合数问题"></a>2.6.1 组合数问题</h3><p>给你一个整数n ，求恰由n个节点组成且节点值从1到n互不相同的二叉搜索树有多少种</p>
<ul>
<li>状态定义<ul>
<li>令f(i, n): 表达序列长度为n, 以i为根的二叉搜索树长度</li>
<li>g(n) 表达长度为n的二叉搜索树长度</li>
</ul>
</li>
<li>状态转移<ul>
<li>g(n) = sum{f(i, n)}</li>
<li>f(i, n) = g(i - 1)*g(n - i)</li>
<li>g(n) = sum{g(i - 1)*g(n - i)}, g(n)这样的组合数, 是数学上的卡特兰数</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](n + <span class="number">1</span>)</span><br><span class="line">    dp(<span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">    dp(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">2</span> to n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to i) &#123;</span><br><span class="line">        dp(i) = dp(i) + dp(j - <span class="number">1</span>) * dp(i - j)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-1-隐晦的递推关系"><a href="#2-5-1-隐晦的递推关系" class="headerlink" title="2.5.1 隐晦的递推关系"></a>2.5.1 隐晦的递推关系</h3><p>有n个一样的骰子，每个骰子上都有f个面，分别标号为 1, 2, …, f<br>约定：掷骰子的得到总点数为各骰子面朝上的数字的总和, 求总点数为target的组合总数, 结果比较大模10^9+7</p>
<ul>
<li>状态定义:<ul>
<li>dp[i][j] 表示i个骰子, target为j的组合总数</li>
</ul>
</li>
<li>状态转移:<ul>
<li>dp[i][j] = d[i - 1][j - 1] + .. + d[i - 1][j - f], 遍历f种骰子的值</li>
</ul>
</li>
<li>初始化:<ul>
<li>dp[0][0] = 0</li>
</ul>
</li>
<li>空间优化<ul>
<li>用滚动数组, 类似0-1背包问题, 用dp[j]就可以,</li>
<li>为了防止覆盖, 遍历方向是从大到小</li>
<li>每一轮遍历j时, 需要dp[j] = 0</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numRollsToTarget</span></span>(n: <span class="type">Int</span>, f: <span class="type">Int</span>, target: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> mod = (<span class="number">1e9</span> + <span class="number">7</span>).toInt</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](target + <span class="number">1</span>)</span><br><span class="line">    dp(<span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- target to <span class="number">0</span> by <span class="number">-1</span>) &#123;</span><br><span class="line">        dp(j) = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (k &lt;- <span class="number">1</span> to f <span class="keyword">if</span> j &gt;= k) &#123;</span><br><span class="line">          dp(j) = (dp(j) + dp(j - k)) % mod</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-数位问题"><a href="#2-7-数位问题" class="headerlink" title="2.7 数位问题"></a>2.7 数位问题</h2><p>求解在一段区间上[L, R]上满足条件的数字的个数<br>例如, 求最大为N的数字组合<br>我们有一组排序的数字 D，它是{‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’} 的非空子集.（请注意，’0’ 不包括在内）<br>用这些数字写数字, 例如’112’, ‘335’, 给定一个整数N, 返回可以用D中的数字能写出的小于或等于N的正整数的数目</p>
<ul>
<li>状态定义<ul>
<li>令N的数位总数为K</li>
<li>dp[i]表示除掉N前面的i位, 剩余的K - i位的合法组合总数, 例如N=2345, dp[0]表示2345, dp[1]表示345,</li>
</ul>
</li>
<li>状态转移<ul>
<li>当s[i] == d, dp[i] += dp[i+ 1], d是digits的十进制值, 顶到s[i]的上边界</li>
<li>当s[i] &gt; d, dp[i] += d_length ** (K - i - 1)</li>
</ul>
</li>
<li>最终答案<ul>
<li>dp[0] += 所有数位小于K的组合总数</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atMostNGivenDigitSet</span></span>(digits: <span class="type">Array</span>[<span class="type">String</span>], <span class="type">N</span>: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> nStr = <span class="type">N</span>.toString</span><br><span class="line">    <span class="keyword">val</span> dLen = digits.size</span><br><span class="line">    <span class="keyword">val</span> digitsValue = digits.map(_.toInt)</span><br><span class="line">    <span class="keyword">val</span> <span class="type">K</span> = nStr.size</span><br><span class="line">    <span class="keyword">val</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="type">K</span> + <span class="number">1</span>)</span><br><span class="line">    dp(<span class="type">K</span>) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="type">K</span> - <span class="number">1</span> to <span class="number">0</span> by <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> iValue = nStr(i) - &#x27;<span class="number">0</span>&#x27;</span><br><span class="line">      <span class="keyword">for</span> (d &lt;- digitsValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; iValue) &#123;</span><br><span class="line">          dp(i) = dp(i) + <span class="type">Math</span>.pow(dLen, <span class="type">K</span> - i - <span class="number">1</span>).toInt</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d == iValue) &#123;</span><br><span class="line">          dp(i) = dp(i) + dp(i + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> until <span class="type">K</span>) &#123;</span><br><span class="line">      dp(<span class="number">0</span>) = dp(<span class="number">0</span>) + <span class="type">Math</span>.pow(dLen, i).toInt</span><br><span class="line">    &#125;</span><br><span class="line">    dp(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><ul>
<li>动态规划的主要特征是最优子结构(最值问题, 组合方案数问题等), 重叠子问题和无后效性</li>
<li>实际问题的难点是识别动态规划的模式, 本篇中主要的模式包括线性问题, 前缀和问题, 区间问题, 背包问题, 状态压缩问题, 计数问题, 数位问题</li>
<li>其实工作中能遇到用动规的场景不多, 学了这个技艺有什么用呢? 我想可以用王国维的一句话, “无用之用, 实为大用”</li>
</ul>
<p>参考:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/detail/dynamic-programming-1-plus/">动态规划精讲 By Leetcode</a></li>
<li>Dynamic Programming for Coding Interviews</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">Algorithm</a><a href="/tags/dynamic-programming/">Dynamic Programming</a>
    </span>
    

    </div>

    
  </div>
</article>

  
	<section id="comments" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'lgrcyanny';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>





    </main>

    <footer class="site-footer">
  <p class="site-info">
    Copyright
    </br>
    
    &copy; 2022 Cyanny Liang
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-40624708-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>